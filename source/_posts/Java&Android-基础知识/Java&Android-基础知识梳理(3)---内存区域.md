---
title: Java&Android 基础知识梳理(3) - 内存区域
date: 2017-03-17 21:45
categories : Java&Android 基础知识梳理
---
# 一、概述
`Java`虚拟机在执行`Java`程序的过程中会把它所**管理的内存**划分为若干个不同的区域，它们有的随着**虚拟机进程**的启动而存在，有些区域则依赖**用户线程**的启动和结束而建立而销毁。
下面，我们就分两个部分讨论：
- 线程隔离的数据区
- 所有线程共享的数据区

# 二、线程隔离的数据区
## 2.1 程序计数器
- 概念
程序计数器是**当前线程所执行的字节码的行号指示器**。字节码解释器工作时会通过改变这个计数器的指来取下一条需要执行的字节码指令。
如果线程正在执行的是`Java`方法，那么计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是`Native`方法，那这个计数器则为空。
此内存区域是唯一一个在`Java`虚拟机规范中没有规定任何`OOM`情况的区域。
- 为什么需要线程隔离
由于`Java`虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器。

## 2.2 `Java`虚拟机栈
- 概念
虚拟机栈描述的是`Java`方法执行的内存模型，每个方法在执行的同时会创建一个栈帧，用于存储**局部变量表、操作数栈、动态链接、方法出口**等信息。
**局部变量表**：存放了编译期可知的各种基本数据类型（`boolean/byte/..`），对象引用（指向对象起始地址的引用指针，或者是指向一个代表对象的句柄，或者是其它与此对象相关的位置）和`returnAddress`地址。
局部变量表**所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在栈中分配多大局部变量空间是完全确定的，在方法运行期间不会改变局部变量表的大小。
每一个方法从调用到执行完成的过程，就对应一个栈帧在虚拟机栈中出栈到入栈的过程。
- 为什么需要线程隔离
因为每个线程所执行的逻辑和时序不同，所以它们的虚拟机栈自然也就不会一定相同，因此不能共用。
- 异常
如果线程请求的栈深度大于虚拟机所允许的深度，会抛出`StackOverflowError`异常；如果虚拟机栈可以动态扩展，当扩展时无法申请到足够的内存，就会抛出`OOM`。

## 2.3 本地方法栈
- 概念
和`Java`虚拟机方法栈类似，不过本地方法栈为虚拟机使用到的`Native`方法，有些虚拟机（譬如`HotSpot`）直接将本地方法栈和虚拟栈合二为一。
- 异常
和虚拟机栈相同。

# 三、线程共享的数据区
## 3.1 `Java`堆
- 概念
`Java`堆在虚拟机启动时创建，它的目的是存放对象实例，它也是垃圾收集器管理的主要区域。
`Java`堆可以处于物理上不连续的内存空间中，只要逻辑上连续即可，在实现上，既可以实现成固定大小的，也可以是可扩展的。
- 异常
如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，会抛出`OOM`异常。

下面我们讨论一下堆中的**对象分配、布局和访问过程**：
### 3.1.1 对象的创建
对象的创建分为以下几步：
- 第一步：当虚拟机遇到一条`new`指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已经被加载、解析和初始化过，如果没有，那么必须执行相应的类加载过程，
- 第二步：接下来虚拟机将为新生对象分配内存，对象所需内存的大小在类加载完成后便可确定，分配的方式有两种：
 - 指针碰撞：用过和空闲的内存以指针作为分界点的指示器，分配内存就是把指针向空闲空间那边挪动一个与对象大小相等距离，这种方式要求内存是规整的。
 - 空闲列表：维护一个列表，记录哪些内存是可用的，在分配和回收时更新列表。

 多线程的问题下的解决方案：
 - 对分配内存空间的动作进行同步，虚拟机上采用`CAS`配上失败重试的方式保证更新操作的原子性。
 - 每个线程在`Java`堆中预先分配一小块内存，成为本地线程分配缓冲`TLAB`，哪个线程需要分配内存，就在哪个线程的`TLAB`上分配，只有`TLAB`用完需要分配新的`TLAB`才需要同步。

- 第三步：在内存分配完成，把除了对象头之外的分配到的内存空间都初始化为零值，接下来就是对对象进行必要的设置，这些信息存放在对象头中。
- 第四步：当对象头设置完毕之后，从虚拟机的视角来看，新的对象就产生了，接着就执行`<init>`方法，把对象按照程序员的意愿进行初始化。

### 3.1.2 对象的内存布局
对象在内存中存储的布局可以分为三个区域：对象头、实例数据、对其填充。
- 对象头
 - 存储对象自身的运行时数据：`HashCode`、`Gc`分代年龄、锁状态标志、线程持有的锁、偏向线程`ID`、偏向时间戳等，所占位数和虚拟机位数相同。
 - 类型指针：对象指向它的**类元数据**的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例
 - 如果对象是一个`Java`数组，那么在对象头中还必须有一块记录数组长度的数据。

- 实例数据
包括在父类和子类中所定义的各种类型的字段内容，存储顺序收到虚拟机分配策略参数的影响，相同宽度的字段总是被分配到一起，在满足这个前提条件下，父类中定义的变量会出现在子类之前。
- 对齐填充
`HotSpot`要求对象的大小必须是`8`字节的整数倍，而对象头部分正好是`8`字节的整数倍，当对象实例数据部分没有对齐时，就需要通过对齐填充来不全。

### 3.1.3 对象的访问
对象的访问有两种方式：
- 使用句柄，`Java`堆中划分出一块内存作为句柄池，`reference`中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的地址信息。
优点：`reference`中存储的是稳定的句柄地址，在对象被移动时，只会改变句柄中的实例数据指针，而`reference`本身不需要修改。
- 直接指针：在`Java`堆对象的布局中放置访问类型数据的相关信息，`reference`中存储的直接就是对象地址。
优点：速度快，`HotSpot`采用的就是这种方式。

## 3.2 方法区
- 概念
方法区用于存储已被虚拟机加载的**类信息、常量、静态变量**、即时编译器编译后的代码等数据。
- 为什么把方法区称为“永久代”
`HotSpot`选择把`GC`分代收集器扩展至方法区，或者说用永久代来实现方法区，这样`HotSpot`的垃圾收集器可以像管理`Java`堆一样管理这部分内存，能够省去专门为这个方法区编写内存管理的代码。
对这区域的内存回收主要是针对常量池的回收和对类型的卸载。
- 异常
当方法区无法满足内存分配需求时，将抛出`OOM`。
- 运行时常量池
运行时常量池是方法区的一部分。
`Class`文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后进入方法区的运行时常量池中存放。
并非预置入`Class`文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，例如`String`类的`intern`方法。
当常量池中无法再申请内存，就会抛出`OOM`异常。
